#! (C) Copyright 2022- ECMWF.
#! (C) Copyright 2022- Meteo-France.
#!
#! This software is licensed under the terms of the Apache Licence Version 2.0
#! which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
#! In applying this licence, ECMWF does not waive the privileges and immunities
#! granted to it by virtue of its status as an intergovernmental organisation
#! nor does it submit to any jurisdiction.

MODULE HOST_ALLOC_MODULE

#:set fieldTypeList = fieldType.getFieldTypeList (alias=False)

${fieldType.useParkind1 ()}$
USE ISO_C_BINDING
#:if defined('CUDA')
USE CUDAFOR
#:endif

IMPLICIT NONE

PRIVATE

INTERFACE HOST_ALLOC
#:for ft in fieldTypeList
  MODULE PROCEDURE ${ft.name}$_HOST_ALLOC
#:endfor
END INTERFACE HOST_ALLOC

INTERFACE HOST_DEALLOC
#:for ft in fieldTypeList
  MODULE PROCEDURE ${ft.name}$_HOST_DEALLOC
#:endfor
END INTERFACE HOST_DEALLOC

INTERFACE
  SUBROUTINE C_MALLOC (SIZ, PTR) BIND (C, NAME='c_malloc')
    IMPORT :: C_PTR, C_SIZE_T
    INTEGER (C_SIZE_T), VALUE, INTENT(IN) :: SIZ
    TYPE (C_PTR), INTENT(OUT) :: PTR
  END SUBROUTINE C_MALLOC
  SUBROUTINE C_FREE (PTR) BIND (C, NAME='c_free')
    IMPORT :: C_PTR
    TYPE (C_PTR), VALUE, INTENT(IN) :: PTR
  END SUBROUTINE C_FREE
END INTERFACE

PUBLIC :: HOST_ALLOC
PUBLIC :: HOST_DEALLOC

CONTAINS

#:for ft in fieldTypeList
#:if defined('CUDA')
SUBROUTINE ${ft.name}$_HOST_ALLOC (HST, LBOUNDS, UBOUNDS, PINNED, DATA)
#:else
SUBROUTINE ${ft.name}$_HOST_ALLOC (HST, LBOUNDS, UBOUNDS, PINNED)
#:endif
   USE FIELD_ABORT_MODULE

   ${ft.type}$, POINTER, INTENT(OUT) :: HST(${ft.shape}$)
   INTEGER(KIND=JPIM), INTENT(IN) :: LBOUNDS(${ft.rank}$)
   INTEGER(KIND=JPIM), INTENT(IN) :: UBOUNDS(${ft.rank}$)
   LOGICAL, INTENT(IN) :: PINNED
#:if defined('CUDA')
   ${ft.type}$, PINNED, ALLOCATABLE, TARGET, INTENT(OUT) :: DATA(${ft.shape}$)
#:endif
   INTEGER(C_SIZE_T) :: ARR_SIZE

   ${ft.type}$, POINTER :: PTR(${ft.shape}$)
#include "abor1.intfb.h"

   ARR_SIZE = KIND(HST)
#:for r in range(ft.rank)
   ARR_SIZE = ARR_SIZE * (UBOUNDS(${r+1}$) - LBOUNDS(${r+1}$) + 1)
#:endfor

  IF(ARR_SIZE > 0 .AND. PINNED)THEN
#:if defined('CUDA')
    ALLOCATE(DATA(${','.join([f'LBOUNDS({r}):UBOUNDS({r})' for r in range(1,ft.rank+1)])}$))
    HST(${', '.join(map(lambda r: 'LBOUNDS('+str(r+1)+'):', range(0, ft.rank)))}$) => DATA
#:endif
  ELSE
   ALLOCATE(HST(${','.join([f'LBOUNDS({r}):UBOUNDS({r})' for r in range(1,ft.rank+1)])}$))
  ENDIF

END SUBROUTINE ${ft.name}$_HOST_ALLOC

#:if defined('CUDA')
SUBROUTINE ${ft.name}$_HOST_DEALLOC(HST, PINNED, DATA)
#:else
SUBROUTINE ${ft.name}$_HOST_DEALLOC(HST, PINNED)
#:endif

   USE FIELD_ABORT_MODULE

   ${ft.type}$, POINTER, INTENT(INOUT) :: HST(${ft.shape}$)
   LOGICAL, INTENT (IN) :: PINNED
#:if defined('CUDA')
   ${ft.type}$, PINNED, ALLOCATABLE, INTENT(INOUT) :: DATA(${ft.shape}$)
#:endif

   IF(SIZE(HST) > 0 .AND. PINNED)THEN
#:if defined('CUDA')
     NULLIFY(HST)
     DEALLOCATE(DATA)
#:endif
   ELSE
     DEALLOCATE(HST)
     NULLIFY(HST)
   ENDIF
   
END SUBROUTINE ${ft.name}$_HOST_DEALLOC

#:endfor

END MODULE HOST_ALLOC_MODULE
